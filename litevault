#!/usr/bin/python
from __future__ import print_function

import os
import sys
import re
import json
import time
import getpass
import subprocess
import signal
import argparse

'''
Notes:
    echo "hi there" | openssl enc -aes-256-cbc -salt -pass pass:hello | openssl aes-256-cbc -salt -d -pass pass:hello
    openssl enc -aes-256-cbc -salt << EOF | openssl aes-256-cbc -salt -d -pass pass:hello
'''

# Python 2 & 3 compatibility
if sys.version_info[0] == 2:
    input = raw_input

##################################################
# Constants

pid_file = '/tmp/litevault.pid'
intro_msg = 'litevault started. Type "?" or "h" for help'
help_msg = '''
Help:
h or ?      = help
q           = quit
c           = clear password
No Argument = get all (same as 'a')
l           = list items. Add an item to do a fuzzy search
u           = get user
p           = get password
i           = get info
a           = get both user and password (insert a TAB between them and end with Return)
'''

ssl_load = "openssl {method} -d -salt -pass stdin -in {path}"
ssl_dump = "openssl enc -{method} -salt -out {path} -pass fd:{fileno} << EOF"
curpass = ''

##################################################
# xdotool mappings
# http://www.linux.org/threads/xdotool-keyboard.6414/

xdotool_char_mappings = {
    '~': 'asciitilde'   , '`': 'quoteleft'   , '!': 'exclam'       , '@': 'at'          ,
    '#': 'numbersign'   , '$': 'dollar'      , '%': 'percent'      , '^': 'asciicircum' ,
    '&': 'ampersand'    , '*': 'asterisk'    , '(': 'parenleft'    , ')': 'parenright'  ,
    '-': 'minus'        , '_': 'underscore'  , '+': 'plus'         , '=': 'equal'       ,
    '[': 'bracketleft'  , '{': 'braceleft'   , ']': 'bracketright' , '}': 'braceright'  ,
    '|': 'bar'          , '\\': 'backslash'  , ':': 'colon'        , ';': 'semicolon'   ,
    '"': 'quotedbl'     , "'": 'quoteright'  , ',': 'comma'        , '<': 'less'        ,
    '.': 'period'       , '>': 'greater'     , '/': 'slash'        , '?': 'question'    ,
    ' ': 'space'        , '\t': 'Tab'        , '\n': 'Return'      ,
}


##################################################
# Convienience Functions

def pplist(l, cols=4, indent=0):
    if not isinstance(l, list):
        l = list(l)
    while len(l) % cols != 0:
        l.append(" ")
    step = len(l) // cols
    step = step if step != 0 else 1
    split = [l[i:i + len(l) // cols] for i in range(0, len(l), step)]
    for row in zip(*split):
        print(' ' * indent + "".join(str.ljust(i, 20) for i in row))


def clear_screen(msg=True):
    out = ''
    if msg:
        if msg is True:
            msg = '\n ** Press ENTER to clear the screen **'
        out = input(msg)
    print('\x1b[0;0H\x1b[2J\n' + intro_msg)
    return out


def output_password(signum, stack):
    '''Output the password on the keyboard'''
    if not curpass:
        return
    k = ' key '
    characters = [c if c not in xdotool_char_mappings else xdotool_char_mappings[c]
                  for c in curpass]
    args = k + k.join(characters)
    subprocess.check_call(('xdotool ' + args).encode().split())


def verify_environment():
    requirements = {
        'openssl': 'openssl version',
        "Xorg's xdotool": 'xdotool --version',
    }
    for r, cmd in requirements.items():
        try:
            subprocess.check_output(cmd.split())
        except Exception as E:
            print('Dependency not met: {}'.format(r))
            sys.exit(1)


##################################################
# Vault object

class Vault(object):
    def __init__(self, path, password, encryption='aes-256-cbc'):
        self.path = path
        self.encryption = encryption
        self.password = password

    @staticmethod
    def _popen(cmd):
        return subprocess.Popen(cmd.encode().split(),
                                stdin=subprocess.PIPE, stdout=subprocess.PIPE,
                                stderr=subprocess.STDOUT)

    def get_vault(self):
        if not os.path.exists(self.path):
            return {}
        cmd = ssl_load.format(method=self.encryption, path=self.path)
        p = self._popen(cmd)
        p.stdin.write(self.password.encode() + b'\n')
        stdout, stderr = p.communicate()
        assert not stderr
        return json.loads(stdout.decode())

    def store_vault(self, vault):
        text = json.dumps(vault).encode()
        passpipe = os.popen('', 'w')
        cmd = ssl_dump.format(method=self.encryption, path=self.path,
                              fileno=passpipe._stream.fileno())
        p = subprocess.Popen(
            cmd.encode(), shell=True,
            stdin=subprocess.PIPE, stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT)
        time.sleep(0.25)
        p.stdin.write(text + b'\nEOF\n')
        passpipe._stream.write(self.password + '\n')
        # passpipe.close()
        stdout, stderr = p.communicate()

        # towrite = text + b'\nEOF\n' + self.password.encode() + b'\n'
        # stdout, stderr = p.communicate(input=towrite)
        assert not stderr
        print(stdout.decode())
        import ipdb; ipdb.set_trace()

    def __getitem__(self, item):
        vault = self.get_vault()
        if item not in vault:
            print("item '{}' not found".format(item))
            return
        return vault[item]

    def __iter__(self):
        return iter(self.get_vault())


##################################################
# User Functions

def load_info(item, vault):
    value = vault[item]
    if value is None:
        return
    key = 'i' if 'i' in value else 'info' if 'info' in value else None
    if key is None:
        print('!! No info for {} !!'.format(item))
        return
    info = value[key]
    print('\n ** Info **\n'.format(item) + info)
    clear_screen()
    return


def load_password(item, vault, append=False):
    global curpass
    value = vault[item]
    if value is None:
        return
    key = 'p' if 'p' in value else 'password' if 'password' in value else None
    if key is None:
        print('!! no password for {} !!'.format(item))
        curpass = ''
        return
    if append:
        curpass += '\t' + value[key] + '\n'
    else:
        curpass = value[key]
    print("  Password ready for: {}".format(item))


def load_user(item, vault):
    global curpass
    value = vault[item]
    if value is None:
        return
    key = 'u' if 'u' in value else 'username' if 'username' in value else None
    if key is None:
        print('!! no username for {} !!'.format(item))
        curpass = ''
        return
    curpass = value[key]
    print("  Username ready for: {}".format(item))


def load_all(item, vault):
    load_user(item, vault)
    load_password(item, vault, append=True)
    load_info(item, vault)


def list_items(vault, item=None):
    print('\n ** Items **')
    if item is None:
        items = list(vault)
    else:
        pat = re.compile(r'.*?'.join(item))
        items = [i for i in vault if pat.search(i)]
    pplist(items)
    user_input = clear_screen("command: ")
    if not user_input:
        return
    execute_command(vault, user_input)


def clear_password():
    global curpass
    curpass = ''
    clear_screen(False)


def execute_command(vault, user_input):
    print_help = lambda item: print(help_msg)
    interface = {
        '?': print_help, 'h': print_help,
        'l': lambda item: list_items(vault, item),
        'u': lambda item: load_username(item, vault),
        'p': lambda item: load_password(item, vault),
        'i': lambda item: load_info(item, vault),
        'a': lambda item: load_all(item, vault),
        'c': lambda item: clear_password(),
        'q': lambda item: sys.exit(0)
    }
    user_input = user_input.split()
    cmd = user_input[0]
    if cmd not in interface:
        cmd = 'a'
        item = ' '.join(user_input)
    else:
        if len(user_input) > 1:
            cmd = user_input[0]
            item = ' '.join(user_input[1:])
        else:
            cmd, = user_input
            item = None
    try:
        return interface[cmd](item)
    except configparser.ParsingError as E:
        print("parsing error: {}".format(E))
        return None


def parse_args():
    parser = argparse.ArgumentParser()
    parser.add_argument('-s', '--send_stored_pass', action='store_true')
    parser.add_argument('-w', '--wait', default=0.25, help="Wait time before sending the stored password")
    parser.add_argument('-p', '--password', help='Use only in testing, not secure!')
    parser.add_argument('-f', '--file', default='~/.auth.aes',
                        help='password file to load. Default is ~/.auth.aes')
    parser.add_argument('-e', '--encryption', default='aes-256-cbc',
                        help='default encryption method to use')
    args = parser.parse_args()
    verify_environment()
    if args.send_stored_pass:
        with open(pid_file, 'rb') as f:
            pid = int(f.read())
        time.sleep(args.wait)
        subprocess.check_output('kill -10 {}'.format(pid).encode(), shell=True)
        sys.exit()
    path = os.path.abspath(os.path.expanduser(args.file))
    if not os.path.exists(path):
        print("Vault file not found: {}".format(path))
        sys.exit(1)
    if not args.password:
        args.password = getpass.getpass("Password for {}: ".format(args.file))
    return Vault(path=path, encryption=args.encryption, password=args.password)


def main():
    signal.signal(signal.SIGINT, lambda *a: sys.exit(1))
    vault = parse_args()
    signal.signal(signal.SIGUSR1, output_password)
    print(intro_msg)
    with open(pid_file, 'w') as f:
        f.write(str(os.getpid()))
    while True:
        user_input = input("command: ")
        if not user_input:
            continue
        execute_command(vault, user_input)


if __name__ == '__main__':
    test_vault()
    # main()
